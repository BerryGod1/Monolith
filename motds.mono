do local valid = true;
local err1 = function() originalError({msg = "Tampering detected. Please contact the owner of this script for a new version."}) while true do end end
local err2 = function() originalError("Tampering detected. Error code: " .. math.random(1000, 9999)) while true do end end
local err3 = function() originalError(function() return "Tampering detected. This incident will be reported." end) while true do end end
local errFuncs = {err1, err2, err3}
local err = errFuncs[math.random(1, #errFuncs)]
local originalError = error
-- Store the original functions in local variables
local originalPairs = pairs
local originalSetmetatable = setmetatable
local originalGetmetatable = getmetatable
local originalType = type
local originalLoad = load
local originalLoadstring = loadstring
local originalPcall = pcall
local originalMathRandom = math.random
local originalXpcall = xpcall
local originalDebug = debug
local originalDebugGetinfo = debug.getinfo
-- Store the original tables in local variables
local originalPackage = package
local originalCoroutine = coroutine
local originalString = string

local originalMath = math
local originalTable = table
local originalOs = os
local originalIo = io
local originalFile = file
local AntiOverwrite = {}
local originalGlobals = {}
for k, v in originalPairs(_G) do
    originalGlobals[k] = v
end

local function protect(t)
    local mt = {
        __index = t,
        __newindex = function(t, k, v)
            if originalGlobals[k] then
                err()
            else
                originalGlobals[k] = v
            end
        end,
        __metatable = false,
        __gc = function()
            err()
        end,
        __mode = "k",
        __call = function()
            err()
        end,
        __len = function()
            err()
        end,
        __pairs = function()
            err()
        end,
        __ipairs = function()
            err()
        end,
        __tostring = function()
            err()
        end,
        __concat = function()
            err()
        end,
        __unm = function()
            err()
        end,
        __add = function()
            err()
        end,
        __sub = function()
            err()
        end,
        __mul = function()
            err()
        end,
        __div = function()
            err()
        end,
        __mod = function()
            err()
        end,
        __pow = function()
            err()
        end,
        __eq = function()
            err()
        end,
        __lt = function()
            err()
        end,
        __le = function()
            err()
        end,
    }
    return originalSetmetatable({}, mt)
end

function AntiOverwrite.protectGlobals()
    for k, v in originalPairs(_G) do
        if originalType(v) == "function" then
            originalGlobals[k] = v
        end
    end
    _G = protect(originalGlobals)
    originalSetmetatable(_G, {
        __metatable = "This metatable is locked."
    })
end

function AntiOverwrite.protectTable(t)
    return protect(t)
end

function AntiOverwrite.protectFunction(f)
    local protectedFunction = function(...)
        return f(...)
    end
    return originalSetmetatable({}, {
        __index = function(t, k)
            if k == '__call' then
                return protectedFunction
            else
                err()
            end
        end,
        __newindex = function(t, k, v)
            err()
        end,
        __metatable = false,
        __gc = function()
            err()
        end,
        __mode = "k",
        __call = function()
            err()
        end,
        __len = function()
            err()
        end,
        __pairs = function()
            err()
        end,
        __ipairs = function()
            err()
        end,
        __debug = function()
            err()
        end,
    })
end

-- Check for hooking attempts
if error ~= originalError or pairs ~= originalPairs or setmetatable ~= originalSetmetatable or getmetatable ~= originalGetmetatable or type ~= originalType or load ~= originalLoad or loadstring ~= originalLoadstring or pcall ~= originalPcall or xpcall ~= originalXpcall or debug ~= originalDebug or package ~= originalPackage or coroutine ~= originalCoroutine or string ~= originalString or math ~= originalMath or table ~= originalTable then
    err()
end

-- Add checks to ensure that the pcall and math.random functions have not been tampered with
if pcall ~= originalPcall or math.random ~= originalMathRandom then
    err()
end

-- List of critical global variables that should not be changed
local criticalGlobals = {"os", "io", "file", "debug"}

-- Check for environment tampering
for _, v in ipairs(criticalGlobals) do
    if _G[v] ~= originalGlobals[v] then
        err()
    end
end

-- Check for debug hooks only if not in Roblox's Luau
local success, result = pcall(originalDebug.gethook)
if success then
    if result then
        err()
    end
end

local gmatch = string.gmatch
local status, pcallErr = pcall(main)

-- Check for changes in the metatable of critical global variables
for _, v in ipairs(criticalGlobals) do
    if getmetatable(_G[v]) ~= getmetatable(originalGlobals[v]) then
        err()
    end
end
local pcallIntact2 = false;
local pcallIntact = originalPcall(function()
    pcallIntact2 = true;
end) and pcallIntact2;



if valid then else
    repeat
        return (function()
            -- tamper detected
            err()
        end)()
    until true;
    return;
end
end






















if valid then
    getgenv().Lynx = {}
    getgenv().thhthgserg=False
    local function htua()
        while True do
            local hwid = tostring(game:GetService("RbxAnalyticsService"):GetClientId())
            local response = game:HttpGet("http://config.lynxlua.space/validate_key?key="..getgenv().key.."&hwid="..hwid) -- This contains the auth killswitch and other stuff so this can to be looped


            hashx=loadstring(game:HttpGet("http://gist.githubusercontent.com/Dekkonot/75d939cbc31fb2f278a3d7d55dc78fd7/raw/e1a8cf16d9781bfa5b37847fa3aa4fcb6f327717/sha1.lua"))()


            local decoded = game:GetService("HttpService"):JSONDecode(response)
            if decoded.message.status == "Valid" then
                if decoded.message.enabled then
                    if decoded.message.hash == hashx(os.date("%Y-%m-%d").."Yan"..hwid..getgenv().key.."1"..tostring(decoded.message.ax)) or decoded.message.hash == hashx(os.date("%Y-%m-%d").."Yan"..hwid..getgenv().key.."3"..tostring(decoded.message.ax)) then -- Only protects when its obfuscated and invalidates cracks after a day
                        print("Auth was successful")
                        discord=decoded.message.ax
                        getgenv().thhthgserg=True
                    else
                        game:GetService("Players").LocalPlayer:Kick("Hash checking failed if this was an error dm berrygod")
                        task.wait(7)
                        game:shutdown()
                        time.wait(5)
                        while true do print("trest") end

                    end
                else
                    game:GetService("Players").LocalPlayer:Kick("Your client was disabled")
                    task.wait(7)
                    game:shutdown()
                    time.wait(5)
                    while true do print("trest") end
                end
            else
                game:GetService("Players").LocalPlayer:Kick("Invalid key or HWID.")
                task.wait(7)
                game:shutdown()
                time.wait(5)
                while true do print("trest") end
            end
            task.wait(30)
        end
    end
    getgenv().uid = nil
    local taskCoro = coroutine.create(htua)
    if getgenv() then
        local hwid = tostring(game:GetService("RbxAnalyticsService"):GetClientId())
        local response = game:HttpGet("http://config.lynxlua.space/validate_key?key="..getgenv().key.."&hwid="..hwid) -- This contains the auth killswitch and other stuff so this can to be looped
        hashx=loadstring(game:HttpGet("http://gist.githubusercontent.com/Dekkonot/75d939cbc31fb2f278a3d7d55dc78fd7/raw/e1a8cf16d9781bfa5b37847fa3aa4fcb6f327717/sha1.lua"))()


        local decoded = game:GetService("HttpService"):JSONDecode(response)
        if decoded.message.status == "Valid" then
            if decoded.message.enabled then
                if decoded.message.hash == hashx(os.date("%Y-%m-%d").."Yan"..hwid..getgenv().key.."1"..tostring(decoded.message.ax)) or decoded.message.hash == hashx(os.date("%Y-%m-%d").."Yan"..hwid..getgenv().key.."3"..tostring(decoded.message.ax)) then -- Only protects when its obfuscated and invalidates cracks after a day
                    print("Auth was successful")
                    print(decoded.message.ax)
                    getgenv().uid=decoded.message.ax
                    getgenv().thhthgserg= True
                else
                    game:GetService("Players").LocalPlayer:Kick("Hash checking failed if this was an error dm berrygod")
                    task.wait(5)
                    game:shutdown()
                    time.wait(1)
                    while true do print("trest") end
                end
            else
                game:GetService("Players").LocalPlayer:Kick("Your client was disabled")
                task.wait(5)
                game:shutdown()
                time.wait(1)
                while true do print("trest") end
            end
        else
            game:GetService("Players").LocalPlayer:Kick("Invalid key or HWID.")
            task.wait(5)
            game:shutdown()
            time.wait(1)
            while true do print("trest") end
        end
    end
    local balls = game:HttpGet("http://discordlookup.mesalytic.moe/v1/user/"..getgenv().uid) -- This contains the auth killswitch and other stuff so this can to be looped
    respx =  game:GetService("HttpService"):JSONDecode(balls)
    if getgenv().thhthgserg then
        local Library = loadstring(game:GetObjects("rbxassetid://7657867786")[1].Source)()
    end

    local function htuax()
        print("here")
        while true do
            print("here1")
            local response = game:HttpGet("http://config.lynxlua.space/get/"..getgenv().key)
            print(response)
            local decodeda = game:GetService("HttpService"):JSONDecode(response)
            print(response)
            print(decodeda)
            getgenv().Lynx = {
                Aimbot = {
                    Keybind = decodeda.AimBotKeyBind,
                    fov = decodeda.fov,
                    AimBotSkid = 0.187,
                    triggerbot = decodeda.Triggerbot,
                    waittime = decodeda.Triggerwait,
                    Prediction = decodeda.Prediction,
                    Silent =  decodeda.Silent,
                    SilentPrediction = decodeda.SilentPrediction,
                    ShakeEnabled = decodeda.Shaking,
                    Shake = decodeda.ShakeAmount,

                    Amount = decodeda.Smooth,
                    Style = "Back",
                    Direction = "Inout",
                    AntiGroundShots = decodeda.AntiGroundShot,
                    TargetPart = decodeda.TargetPart,
                    JumpOffset = decodeda.JumpOffset,
                    MultipleTargetPart = decodeda.TargetPart
                
                },
                ['OffSets'] = {
                    Jump = {Amount = 0.90},
                    Fall = {Amount = -1.50},
                },  
                ['Air'] = {
                    Enabled = true,
                    AirPart = "Head",
                },
                ['Checks'] = {
                    TargetDeath = decodeda.TargetDeath,
                    PlayerDeath = decodeda.Alive,
                },

                ['Macro'] = {
                    Enabled = false,
                    Keybind = decodeda.MacroKeybind,
                    Speed = 0.0200,
                    Type = "Third", -- "First", "Third"
                },
            }
            task.wait(0.3)
        end
    end
    local taskCoro = coroutine.wrap(htuax)
    taskCoro()
    task.wait(2)


    if (not getgenv().Loaded) then
    local userInputService = game:GetService("UserInputService")

    local function CheckAnti(Plr) -- // Anti-aim detection
        if Plr.Character.HumanoidRootPart.Velocity.Y < -70 then
            return true
        elseif Plr and (Plr.Character.HumanoidRootPart.Velocity.X > 450 or Plr.Character.HumanoidRootPart.Velocity.X < -35) then
            return true
        elseif Plr and Plr.Character.HumanoidRootPart.Velocity.Y > 60 then
            return true
        elseif Plr and (Plr.Character.HumanoidRootPart.Velocity.Z > 35 or Plr.Character.HumanoidRootPart.Velocity.Z < -35) then
            return true
        else
            return false
        end
    end

    local function getnamecall()
         if game.PlaceId == 2788229376 or game.PlaceId == 7213786345 or game.PlaceId == 16033173781 or game.PlaceId == 16158576873 then 
            return "UpdateMousePosI"
        elseif game.PlaceId == 5602055394 or game.PlaceId == 7951883376 then
            return "MousePos"
        elseif game.PlaceId == 9825515356 then
            return "GetMousePos"
        end
    end

    function MainEventLocate()
        for _,v in pairs(game:GetService("ReplicatedStorage"):GetDescendants()) do
            if v.Name == "MainEvent" then
                return v
            end
        end
    end

    local Locking = false
    local Players = game:GetService("Players")
    local Client = Players.LocalPlayer
    local Plr = nil -- Initialize Plr here

    -- 360 on bind
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera
    local Toggle = false -- Initialize Toggle to false
    getgenv().Lynx.Macro.SpeedGlitch = false
    local function OnKeyPress(Input, GameProcessedEvent)
        if Input.KeyCode.Name == string.upper(getgenv().Lynx.Aimbot.Keybind) and not GameProcessedEvent then 
            Toggle = not Toggle
        elseif Input.KeyCode.Name == string.upper(getgenv().Lynx.Macro.Keybind) then
            if getgenv().Lynx.Macro.Enabled then 
                getgenv().Lynx.Macro.SpeedGlitch = not getgenv().Lynx.Macro.SpeedGlitch
                if getgenv().Lynx.Macro.SpeedGlitch then
                    repeat
                        game:GetService("RunService").Heartbeat:Wait()
                        keypress(0x49)
                        game:GetService("RunService").Heartbeat:Wait()
                        keypress(0x4F)
                        game:GetService("RunService").Heartbeat:Wait()
                        keyrelease(0x49)
                        game:GetService("RunService").Heartbeat:Wait()
                        keyrelease(0x4F)
                        game:GetService("RunService").Heartbeat:Wait()
                    until not getgenv().Lynx.Macro.SpeedGlitch
                end
            end
        end
    end

    UserInputService.InputBegan:Connect(OnKeyPress)

    UserInputService.InputBegan:Connect(function(keygo, ok)
        if (not ok) then
            if (keygo.KeyCode.Name == string.upper(getgenv().Lynx.Aimbot.Keybind)) then
                Locking = not Locking
                if Locking then
                    Plr = getClosestPlayerToCursor()
                elseif not Locking then
                    if Plr then
                        Plr = nil
                    end
                end
            end
        end
    end)

    function getClosestPlayerToCursor()
        local closestDist = math.huge
        local closestPlr = nil
        for _, v in ipairs(Players:GetPlayers()) do
            if v ~= Client and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                local screenPos, cameraVisible = workspace.CurrentCamera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                local ssHeadPoint = cam:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
                ssHeadPoint = Vector2.new(ssHeadPoint.X, ssHeadPoint.Y)
                if (ssHeadPoint - zz).Magnitude < getgenv().Lynx.Aimbot.fov then
                        if cameraVisible then
                            local distToMouse = (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                            if distToMouse < closestDist then
                                closestPlr = v
                                closestDist = distToMouse
                            end
                        end
                    end
                end
            end
        end
        return closestPlr
    end

    function getClosestPartToCursor(Player)
        local closestPart, closestDist = nil, math.huge
        if Player.Character and Player.Character:FindFirstChild("Humanoid") and Player.Character:FindFirstChild("Head") and Player.Character.Humanoid.Health ~= 0 and Player.Character:FindFirstChild("HumanoidRootPart") then
            for i, part in pairs(Player.Character:GetChildren()) do
                if part:IsA("BasePart") then
                    local screenPos, cameraVisible = workspace.CurrentCamera:WorldToViewportPoint(part.Position)
                    local distToMouse = (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                    if distToMouse < closestDist and table.find(getgenv().Lynx.Aimbot.MultipleTargetPart, part.Name) then
                        closestPart = part
                        closestDist = distToMouse
                    end
                end
            end
            return closestPart
        end
    end

    game:GetService("RunService").RenderStepped:Connect(function()
        if Plr and Plr.Character then
            if getgenv().Lynx.Aimbot.NearestPart == true and getgenv().Lynx.Aimbot.Basic == false then
                getgenv().Lynx.Aimbot.TargetPart = tostring(getClosestPartToCursor(Plr))
            elseif getgenv().Lynx.Aimbot.Basic == true and getgenv().Lynx.Aimbot.NearestPart == false then
                getgenv().Lynx.Aimbot.TargetPart = getgenv().Lynx.Aimbot.TargetPart
            end
        end
    end)

    local function getVelocity(Player)
        local Old = Player.Character.HumanoidRootPart.Position
        wait(0.145)
        local Current = Player.Character.HumanoidRootPart.Position
        return (Current - Old) / 0.145
    end

    local function GetShakedVector3(Setting)
        return Vector3.new(math.random(-Setting * 1e9, Setting * 1e9), math.random(-Setting * 1e9, Setting * 1e9), math.random(-Setting * 1e9, Setting * 1e9)) / 1e9;
    end

    local v = nil
    game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
        if Plr ~= nil and Plr.Character and Plr.Character:FindFirstChild("HumanoidRootPart") then
            v = getVelocity(Plr)
        end
    end)

    local mainevent = game:GetService("ReplicatedStorage").MainEvent

    Client.Character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") and child:FindFirstChild("MaxAmmo") then
            child.Activated:Connect(function()
                if Plr and Plr.Character then
                    local Position = Plr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall and Plr.Character[getgenv().Lynx.Aimbot.TargetPart].Position + Vector3.new(0, getgenv().Lynx.Aimbot.JumpOffset, 0) or Plr.Character[getgenv().Lynx.Aimbot.TargetPart].Position
                    if not CheckAnti(Plr) then
                        mainevent:FireServer("UpdateMousePosI", Position + ((Plr.Character.HumanoidRootPart.Velocity) * getgenv().Lynx.Aimbot.Prediction))
                    else
                        mainevent:FireServer("UpdateMousePosI", Position + ((Plr.Character.Humanoid.MoveDirection * Plr.Character.Humanoid.WalkSpeed) * getgenv().Lynx.Aimbot.Prediction))
                    end
                end
            end)
        end
    end)

    Client.CharacterAdded:Connect(function(character)
        character.ChildAdded:Connect(function(child)
            if child:IsA("Tool") and child:FindFirstChild("MaxAmmo") then
                child.Activated:Connect(function()
                    if Plr and Plr.Character then
                        local Position = Plr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall and Plr.Character[getgenv().Lynx.Aimbot.TargetPart].Position + Vector3.new(0, getgenv().Lynx.Aimbot.JumpOffset, 0) or Plr.Character[getgenv().Lynx.Aimbot.TargetPart].Position
                        if not CheckAnti(Plr) then
                            mainevent:FireServer("UpdateMousePosI", Position + ((Plr.Character.HumanoidRootPart.Velocity) * getgenv().Lynx.Aimbot.Prediction))
                        else
                            mainevent:FireServer("UpdateMousePosI", Position + ((Plr.Character.Humanoid.MoveDirection * Plr.Character.Humanoid.WalkSpeed) * getgenv().Lynx.Aimbot.Prediction))
                        end
                    end
                end)
            end
        end)
    end)
    game:GetService("RunService").RenderStepped:Connect(function()
        if getgenv().Lynx.Aimbot.triggerbot then
            shouldtrigger = true
            local mouse = game:GetService("Players").LocalPlayer:GetMouse()
            if getgenv().Lynx.Checks.PlayerDeath == true and Plr and Plr.Character then
                local KOd = Plr.Character:WaitForChild("BodyEffects")["K.O"].Value
                local Grabbed = Plr.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
                if Plr.Character.Humanoid.Health < 1 or KOd or Grabbed then
                    shouldtrigger = false
                end
            end
            if getgenv().Lynx.Checks.TargetDeath == true and Plr and Plr.Character:FindFirstChild("Humanoid") then
                if Plr.Character.Humanoid.health < 1 then
                    shouldtrigger = false
                end
            end
            if getgenv().Lynx.Checks.PlayerDeath  == true and Client.Character and Client.Character:FindFirstChild("Humanoid") and Client.Character.Humanoid.health < 1 then
                shouldtrigger = false
            end
            if mouse.Target.Parent:FindFirstChildOfClass("Humanoid") and mouse.Target.Parent:FindFirstChildOfClass("Humanoid").Health > 0 and shouldtrigger then
                task.wait(getgenv().Lynx.Aimbot.waittime)
                mouse1press()
                repeat
                    game:GetService("RunService").RenderStepped:Wait()
                until not mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
                mouse1release()
            end
        end
    end)
    game:GetService("RunService").RenderStepped:Connect(function()
        if Plr ~= nil and Plr.Character then
            local Position = Plr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall and Plr.Character[getgenv().Lynx.Aimbot.TargetPart].Position + Vector3.new(0, getgenv().Lynx.Aimbot.JumpOffset, 0) or Plr.Character[getgenv().Lynx.Aimbot.TargetPart].Position
            if not CheckAnti(Plr) then
                local Main = CFrame.new(workspace.CurrentCamera.CFrame.p, Position + ((Plr.Character.HumanoidRootPart.Velocity) * getgenv().Lynx.Aimbot.AimBotSkid) + GetShakedVector3(getgenv().Lynx.Aimbot.Shake))
                workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(Main, getgenv().Lynx.Aimbot.Amount, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
            else
                local Main = CFrame.new(workspace.CurrentCamera.CFrame.p, Position + ((Plr.Character.Humanoid.MoveDirection * Plr.Character.Humanoid.WalkSpeed) * getgenv().Lynx.Aimbot.AimBotSkid) + GetShakedVector3(getgenv().Lynx.Aimbot.CameraShake))
                workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(Main, getgenv().Lynx.Aimbot.Amount, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
            end
        end
        if getgenv().Lynx.Checks.PlayerDeath == true and Plr and Plr.Character then
            local KOd = Plr.Character:WaitForChild("BodyEffects")["K.O"].Value
            local Grabbed = Plr.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
            if Plr.Character.Humanoid.Health < 1 or KOd or Grabbed then
                if Locking == true then
                    Plr = nil
                    Locking = false
                end
            end
        end
        if getgenv().Lynx.Checks.TargetDeath == true and Plr and Plr.Character:FindFirstChild("Humanoid") then
            if Plr.Character.Humanoid.health < 1 then
                if Locking == true then
                    Plr = nil
                    Locking = false
                end
            end
        end
        if getgenv().Lynx.Checks.PlayerDeath  == true and Client.Character and Client.Character:FindFirstChild("Humanoid") and Client.Character.Humanoid.health < 1 then
            if Locking == true then
                Plr = nil
                Locking = false
            end
        end
        if getgenv().Lynx.Aimbot.AntiGroundShots == true and Plr.Character.Humanoid.Jump == true and Plr.Character.Humanoid.FloorMaterial == Enum.Material.Air then
            pcall(function()
                local TargetVelv5 = Plr.Character.HumanoidRootPart
        TargetVelv5.Velocity = Vector3.new(TargetVelv5.Velocity.X, math.abs(TargetVelv5.Velocity.Y * 0.36),
         TargetVelv5.Velocity.Z)
                TargetVelv5.AssemblyLinearVelocity = Vector3.new(TargetVelv5.Velocity.X, math.abs(TargetVelv5.Velocity.Y * 0.36), TargetVelv5.Velocity.Z)
            end)
        end
    end)


    getgenv().Loaded = true -- end of the script
    else
    	print("genyo")
    end
end
